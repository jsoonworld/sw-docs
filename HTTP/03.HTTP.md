# 03. HTTP

## HyperText Transfer Protocol

### 모든 것이 HTTP
HTTP 메시지에 모든 것을 전송
- HTML, TEXT 
- IMAGE, 음성, 영상, 파일 
- JSON, XML (API)
- 거의 모든 형태의 데이터 전송 가능 
- 서버간에 데이터를 주고 받을 때도 대부분 HTTP 사용

## HTTP 역사


- HTTP/0.9 1991년: GET 메서드만 지원, HTTP 헤더X 
- HTTP/1.0 1996년: 메서드, 헤더 추가 
- `HTTP/1.1 1997년: 가장 많이 사용, 우리에게 가장 중요한 버전` 
  - RFC2068 (1997) -> RFC2616 (1999) -> RFC7230~7235 (2014)
- HTTP/2 2015년: 성능 개선 
- HTTP/3 진행중: TCP 대신에 UDP 사용, 성능 개선

## 기반 프로토콜


- TCP: HTTP/1.1, HTTP/2 
- UDP: HTTP/3 
- 현재 HTTP/1.1 주로 사용 
  - HTTP/2, HTTP/3 도 점점 증가


## HTTP 특징

- 클라이언트 서버 구조 
- 무상태 프로토콜(스테이스리스), 비연결성 
- HTTP 메시지 
- 단순함, 확장 가능

## 클라이언트 서버 구조

- Request Response 구조 
- 클라이언트는 서버에 요청을 보내고, 응답을 대기 
- 서버가 요청에 대한 결과를 만들어서 응답


## Stateful vs Stateless

### Stateful

Stateful 시스템에서, 서버는 클라이언트의 상태를 기억한다.
상태 정보는 세션을 통해 여러 요청에 걸쳐 유지된다.
이는 서버가 이전의 상호작용을 바탕으로 후속 요청을 처리할 수 있음을 의미한다.
Stateful 프로토콜의 예로는 TCP(Transmission Control Protocol)가 있다.

#### 장점:
- 연속된 요청 간의 컨텍스트가 유지되므로, 사용자의 경험이 더 부드럽고 일관성 있다.
- 복잡한 트랜잭션이나 작업을 처리할 때 유용하다.

#### 단점:
- 세션 정보를 저장하고 관리해야 하기 때문에 서버의 자원을 더 많이 사용한다.
- 확장성이 제한될 수 있으며, 서버 장애 시 세션 복구가 어려울 수 있다.

### Stateless

Stateless 시스템에서, 서버는 클라이언트의 상태를 기억하지 않는다.
각 요청은 독립적이며, 서버는 이전 요청에 대한 정보 없이도 각 요청을 처리한다.
HTTP(Hypertext Transfer Protocol)는 Stateless 프로토콜의 예다.

#### 장점:
- 서버는 상태 정보를 유지할 필요가 없으므로 더 단순하고 확장성이 높다.
- 부하 분산이나 서버 장애 대응이 용이.

#### 단점:
- 모든 요청이 독립적이므로, 연속된 요청에서 중복된 데이터를 전송해야 할 수도 있다.
- 사용자 세션을 유지하기 위해서는 클라이언트 측에서 추가 로직이 필요할 수 있다.

### 결론

Stateful과 Stateless 간의 선택은 애플리케이션의 요구 사항과 서버 자원, 
확장성 등을 고려하여 결정해야 한다. Stateless 아키텍처는 웹 애플리케이션과 
마이크로서비스에서 널리 사용되며, Stateful은 복잡한 트랜잭션이나 
상태 정보가 중요한 애플리케이션에 적합할 수 있다.


## 비 연결성
### 한계와 극복
- TCP/IP 연결을 새로 맺어야 함 - 3 way handshake 시간 추가 
- 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 자바스크립트, css, 추가 이미지 등
등 수 많은 자원이 함께 다운로드 
- 지금은 HTTP 지속 연결(Persistent Connections)로 문제 해결 
- HTTP/2, HTTP/3에서 더 많은 최적화

# HTTP 메시지

HTTP (Hypertext Transfer Protocol) 메시지는 웹에서 데이터를 
교환하는 데 사용되는 형식이다. 클라이언트(보통 웹 브라우저)와 
서버 간의 통신에 사용되며, 두 가지 주요 유형이 있다: 
- 요청 메시지
- 응답 메시지

## HTTP 요청 메시지

웹 브라우저에서 웹 페이지나 이미지와 같은 리소스를 요청할 때 사용하는 메시지이다.

### 구조
1. **시작줄(Start line)** - 요청 방식(GET, POST 등), 
요청할 리소스의 URI, HTTP 버전 정보를 포함한다.
2. **헤더(Headers)** - 서버에 전달할 추가 정보를 포함한 메타데이터이다. 
예를 들어, `Host`, `User-Agent`, `Accept` 등이 있다.
3. **빈 줄(Empty line)** - 헤더와 본문을 구분하는 데 사용되는 빈 줄이다.
4. **본문(Body)** - 요청과 함께 전송될 데이터이다.
POST 요청에서 폼 데이터나 파일을 보낼 때 사용된다.

## HTTP 응답 메시지

서버가 클라이언트의 요청에 대해 보내는 메시지이다.

### 구조
1. **시작줄(Start line)** - HTTP 버전, 
상태 코드(200, 404 등), 상태 메시지를 포함한다.
2. **헤더(Headers)** - 응답에 대한 추가 정보를 포함한 메타데이터이다. 
예를 들어, `Content-Type`, `Content-Length`, `Set-Cookie` 등이 있다.
3. **빈 줄(Empty line)** - 헤더와 본문을 구분하는 데 사용되는 빈 줄이다.
4. **본문(Body)** - 서버가 클라이언트에 보내는 데이터이다. 
웹 페이지의 HTML 문서나 이미지 파일 등이 여기에 해당한다.

## 상태 코드

응답 메시지의 시작줄에 포함되는 상태 코드는 요청의 성공 여부와 그 유형을 나타냅니다.

- **1xx (정보)**: 요청을 받았으며 프로세스가 계속되고 있음
- **2xx (성공)**: 요청이 성공적으로 받아들여졌음
- **3xx (리다이렉션)**: 추가 조치가 필요하여 리다이렉션을 나타냄
- **4xx (클라이언트 에러)**: 클라이언트의 잘못된 요청을 나타냄
- **5xx (서버 에러)**: 서버가 요청을 처리하지 못함을 나타냄








